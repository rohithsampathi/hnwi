// =============================================================================
// USE PATTERN AUDIT HOOK
// API calls, state management, PDF export for SFO Pattern Audit
// =============================================================================

import { useCallback } from 'react';

// Razorpay type declaration
declare global {
  interface Window {
    Razorpay: any;
  }
}
import {
  SFOPatternAuditIntake,
  ICArtifact,
  PreviewArtifact,
  AuditSession,
  PatternAuditAPIPayload
} from '@/lib/decision-memo/pattern-audit-types';

const API_BASE = '/api/decision-memo';

export function usePatternAudit() {
  // ==========================================================================
  // SUBMIT INTAKE
  // Returns session with preview URL (audit takes 48 hours)
  // ==========================================================================

  const submitIntake = useCallback(async (
    intake: SFOPatternAuditIntake
  ): Promise<{ session: AuditSession; preview?: PreviewArtifact }> => {
    const payload = transformIntakeToAPI(intake);
    console.log('üì§ [SFO Submit] Submitting intake:', JSON.stringify(payload, null, 2));

    const response = await fetch(`${API_BASE}/submit-sfo-intake`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå [SFO Submit] Failed:', response.status, errorText);
      throw new Error('Failed to submit intake');
    }

    const data = await response.json();
    console.log('üì¶ [SFO Submit] Raw response:', JSON.stringify(data, null, 2));

    // Handle different response formats
    const sessionData = data.session || data;
    if (!sessionData || !sessionData.intake_id) {
      console.error('‚ùå [SFO Submit] Invalid response - missing intake_id:', data);
      throw new Error('Invalid response from server');
    }

    console.log('üìã [SFO Submit] Session data:', sessionData);
    const session = transformSessionFromAPI(sessionData);
    console.log('‚ú® [SFO Submit] Transformed session:', session);

    // If backend returns preview data directly, transform it
    let preview: PreviewArtifact | undefined;
    if (data.is_preview && data.preview) {
      console.log('üéØ [SFO Submit] Preview data included in response:');
      console.log('  - is_preview:', data.is_preview);
      console.log('  - preview:', JSON.stringify(data.preview, null, 2));
      console.log('  - call_to_action:', data.call_to_action);

      preview = transformPreviewFromAPI({
        intake_id: data.intake_id,
        generated_at: data.generated_at,
        ...data.preview,
        call_to_action: data.call_to_action
      });
      console.log('‚ú® [SFO Submit] Transformed preview:', preview);
    } else {
      console.log('‚ÑπÔ∏è [SFO Submit] No preview data in response (is_preview:', data.is_preview, ')');
    }

    return { session, preview };
  }, []);

  // ==========================================================================
  // GET SESSION STATUS
  // Check current status of an audit
  // ==========================================================================

  const getSession = useCallback(async (intakeId: string): Promise<AuditSession> => {
    console.log('üîç [SFO Session] Fetching session for:', intakeId);

    const response = await fetch(`${API_BASE}/session/${intakeId}`);

    if (!response.ok) {
      console.error('‚ùå [SFO Session] Response not OK:', response.status);
      throw new Error('Failed to fetch session');
    }

    const data = await response.json();
    console.log('üì¶ [SFO Session] Raw response:', JSON.stringify(data, null, 2));

    // Handle different response formats
    const sessionData = data.session || data;
    if (!sessionData || !sessionData.intake_id) {
      console.error('‚ùå [SFO Session] Invalid response - missing intake_id:', data);
      throw new Error('Invalid session data received');
    }

    const session = transformSessionFromAPI(sessionData);
    console.log('‚ú® [SFO Session] Transformed session:', session);

    return session;
  }, []);

  // ==========================================================================
  // GET PREVIEW ARTIFACT
  // Fetch the preview artifact (available after PREVIEW_READY status)
  // ==========================================================================

  const getPreviewArtifact = useCallback(async (
    intakeId: string
  ): Promise<PreviewArtifact> => {
    console.log('üîç [SFO Preview] Fetching preview for:', intakeId);

    const response = await fetch(`${API_BASE}/preview/${intakeId}`);

    if (!response.ok) {
      console.error('‚ùå [SFO Preview] Response not OK:', response.status);
      throw new Error('Preview not ready');
    }

    const data = await response.json();
    console.log('üì¶ [SFO Preview] Raw API response:', JSON.stringify(data, null, 2));

    // Handle different response formats
    const previewData = data.preview || data;
    console.log('üìã [SFO Preview] Preview data extracted:', JSON.stringify(previewData, null, 2));

    if (!previewData || !previewData.intake_id) {
      console.error('‚ùå [SFO Preview] Invalid preview response - missing intake_id:', data);
      throw new Error('Invalid preview data received');
    }

    // Log each preview section
    console.log('üéØ [SFO Preview] Sections received:');
    console.log('  - verdict:', previewData.verdict ? '‚úÖ' : '‚ùå', previewData.verdict);
    console.log('  - sequence_preview:', previewData.sequence_preview ? '‚úÖ' : '‚ùå', previewData.sequence_preview);
    console.log('  - failure_modes_preview:', previewData.failure_modes_preview ? '‚úÖ' : '‚ùå', previewData.failure_modes_preview);
    console.log('  - pattern_anchors_preview:', previewData.pattern_anchors_preview ? '‚úÖ' : '‚ùå', previewData.pattern_anchors_preview);
    console.log('  - next_step_preview:', previewData.next_step_preview ? '‚úÖ' : '‚ùå', previewData.next_step_preview);
    console.log('  - scope_preview:', previewData.scope_preview ? '‚úÖ' : '‚ùå', previewData.scope_preview);
    console.log('  - intelligence_preview:', previewData.intelligence_preview ? '‚úÖ' : '‚ùå', previewData.intelligence_preview);
    console.log('  - call_to_action:', previewData.call_to_action ? '‚úÖ' : '‚ùå', previewData.call_to_action);

    const transformed = transformPreviewFromAPI(previewData);
    console.log('‚ú® [SFO Preview] Transformed preview:', transformed);

    return transformed;
  }, []);

  // ==========================================================================
  // GENERATE AUDIT (Legacy - for immediate generation without 48h wait)
  // ==========================================================================

  const generateAudit = useCallback(async (
    intake: SFOPatternAuditIntake
  ): Promise<ICArtifact> => {
    const payload = transformIntakeToAPI(intake);

    const response = await fetch(`${API_BASE}/generate-ic-artifact`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      throw new Error('Audit generation failed');
    }

    const data = await response.json();
    return transformArtifactFromAPI(data.artifact);
  }, []);

  // ==========================================================================
  // CREATE PAYMENT ORDER
  // Create Razorpay order for SFO audit
  // ==========================================================================

  const createPaymentOrder = useCallback(async (
    intakeId: string,
    currency: 'INR' | 'USD' = 'INR'
  ) => {
    const response = await fetch(`${API_BASE}/sfo-audit/${intakeId}/create-order`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ currency })
    });

    if (!response.ok) {
      throw new Error('Failed to create payment order');
    }

    return response.json();
  }, []);

  // ==========================================================================
  // INITIATE PAYMENT
  // Create payment order with tier selection support
  // ==========================================================================

  const initiatePayment = useCallback(async (
    intakeId: string,
    options?: { tier?: string; amount?: number; currency?: 'INR' | 'USD' }
  ) => {
    console.log('üí≥ [Payment] Initiating payment for:', intakeId, options);

    const response = await fetch(`${API_BASE}/sfo-audit/${intakeId}/create-order`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        currency: options?.currency || 'USD',
        tier: options?.tier || 'single',
        amount: options?.amount
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error('‚ùå [Payment] API error:', response.status, errorData);
      throw new Error(errorData.message || errorData.error || 'Failed to create payment order');
    }

    const data = await response.json();
    console.log('üì¶ [Payment] Raw API response:', JSON.stringify(data, null, 2));

    // Check if backend returned success: false
    if (data.success === false) {
      // Special case: already paid - signal to fetch full artifact
      if (data.error === 'already_paid') {
        console.log('‚úÖ [Payment] Already paid - returning special marker');
        return { already_paid: true, intake_id: data.intake_id };
      }
      console.error('‚ùå [Payment] Backend returned success: false:', data);
      throw new Error(data.error || data.message || 'Backend rejected payment order');
    }

    // Extract order details - handle different response formats
    const orderId = data.order_id || data.orderId;
    const amount = data.amount;
    const currency = data.currency;
    const key = data.key_id || data.key || data.razorpay_key;

    console.log('‚ú® [Payment] Extracted order details:', { orderId, amount, currency, key: key ? '***' : 'MISSING' });

    if (!orderId || !key) {
      console.error('‚ùå [Payment] Missing required fields:', { orderId, key: !!key });
      throw new Error('Invalid payment order response - missing order_id or key');
    }

    return {
      order_id: orderId,
      amount: amount,
      currency: currency,
      key: key
    };
  }, []);

  // ==========================================================================
  // VERIFY PAYMENT
  // Verify Razorpay payment and get full artifact
  // ==========================================================================

  const verifyPayment = useCallback(async (
    intakeId: string,
    razorpayResponse: {
      razorpay_order_id: string;
      razorpay_payment_id: string;
      razorpay_signature: string;
    }
  ): Promise<ICArtifact> => {
    const response = await fetch(`${API_BASE}/sfo-audit/${intakeId}/verify-payment`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(razorpayResponse)
    });

    if (!response.ok) {
      throw new Error('Payment verification failed');
    }

    const data = await response.json();
    if (!data.success || !data.artifact) {
      throw new Error(data.message || 'Failed to unlock artifact');
    }

    return transformArtifactFromAPI(data.artifact);
  }, []);

  // ==========================================================================
  // CHECK PAYMENT STATUS
  // Check if audit has been paid for
  // ==========================================================================

  const checkPaymentStatus = useCallback(async (intakeId: string) => {
    const response = await fetch(`${API_BASE}/sfo-audit/${intakeId}/payment-status`);

    if (!response.ok) {
      throw new Error('Failed to check payment status');
    }

    return response.json();
  }, []);

  // ==========================================================================
  // OPEN RAZORPAY CHECKOUT
  // Full payment flow: create order -> open checkout -> verify -> get artifact
  // ==========================================================================

  const openPaymentCheckout = useCallback(async (
    intakeId: string,
    options: {
      currency?: 'INR' | 'USD';
      prefill?: { name?: string; email?: string; phone?: string };
      onSuccess: (artifact: ICArtifact) => void;
      onFailure: (error: Error) => void;
    }
  ) => {
    try {
      // Load Razorpay SDK if not loaded
      if (!window.Razorpay) {
        await new Promise<void>((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://checkout.razorpay.com/v1/checkout.js';
          script.async = true;
          script.onload = () => resolve();
          script.onerror = () => reject(new Error('Failed to load Razorpay SDK'));
          document.body.appendChild(script);
        });
      }

      // Create order
      const orderData = await createPaymentOrder(intakeId, options.currency || 'INR');

      if (!orderData.success) {
        throw new Error(orderData.message || 'Failed to create order');
      }

      // Build prefill data
      const prefillData: { name?: string; email?: string; contact?: string } = {};
      if (options.prefill?.name?.trim()) prefillData.name = options.prefill.name.trim();
      if (options.prefill?.email?.trim()) prefillData.email = options.prefill.email.trim();
      if (options.prefill?.phone?.trim()) prefillData.contact = options.prefill.phone.trim();

      // Open Razorpay checkout
      const razorpayOptions = {
        key: orderData.key_id,
        amount: orderData.amount,
        currency: orderData.currency,
        name: 'HNWI Chronicles',
        description: orderData.description || 'SFO Pattern Audit - IC Artifact',
        order_id: orderData.order_id,
        remember_customer: false,
        ...(Object.keys(prefillData).length > 0 ? { prefill: prefillData } : {}),
        theme: { color: '#DAA520' },
        handler: async (response: any) => {
          try {
            const artifact = await verifyPayment(intakeId, {
              razorpay_order_id: response.razorpay_order_id,
              razorpay_payment_id: response.razorpay_payment_id,
              razorpay_signature: response.razorpay_signature
            });
            options.onSuccess(artifact);
          } catch (error) {
            options.onFailure(error instanceof Error ? error : new Error('Verification failed'));
          }
        },
        modal: {
          ondismiss: () => {
            options.onFailure(new Error('Payment cancelled'));
          }
        }
      };

      const razorpay = new window.Razorpay(razorpayOptions);
      razorpay.open();

    } catch (error) {
      options.onFailure(error instanceof Error ? error : new Error('Failed to open checkout'));
    }
  }, [createPaymentOrder, verifyPayment]);

  // ==========================================================================
  // GET FULL ARTIFACT
  // Fetch complete artifact (available after PAID/FULL_READY status)
  // ==========================================================================

  const getFullArtifact = useCallback(async (
    intakeId: string
  ): Promise<ICArtifact> => {
    const response = await fetch(`${API_BASE}/artifact/${intakeId}`);

    if (!response.ok) {
      throw new Error('Artifact not available');
    }

    const data = await response.json();
    console.log('üì¶ [getFullArtifact] Raw response keys:', Object.keys(data));

    // Backend sends data at TOP LEVEL (preview_data, memo_data), NOT nested under 'artifact'
    // Handle both formats for backwards compatibility
    const artifactData = data.artifact || data;
    console.log('üì¶ [getFullArtifact] Using artifact data with keys:', Object.keys(artifactData));

    return transformArtifactFromAPI(artifactData);
  }, []);

  // ==========================================================================
  // EXPORT PDF
  // Client-side PDF generation - each section on new page
  // ==========================================================================

  const exportPDF = useCallback(async (artifact: ICArtifact) => {
    // Use institutional-grade PDF export for $2,500 audits
    const { exportInstitutionalPDF } = await import('./usePremiumPDFExport');
    return await exportInstitutionalPDF(artifact);
  }, []);

  // Old PDF generation code removed - now using institutional-grade export
    const pageWidth = 210;
    const pageHeight = 297;

    // ========================================================================
    // PREMIUM COVER PAGE
    // ========================================================================
    console.log('üìÑ Creating premium cover page...');

    // Black background for luxury feel
    pdf.setFillColor(0, 0, 0);
    pdf.rect(0, 0, pageWidth, pageHeight, 'F');

    // Gold accent line at top
    pdf.setFillColor(212, 175, 55); // Gold
    pdf.rect(0, 0, pageWidth, 2, 'F');

    // Main title
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(32);
    pdf.setTextColor(255, 255, 255);
    pdf.text('HNWI CHRONICLES', pageWidth / 2, 70, { align: 'center' });

    // Subtitle
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(18);
    pdf.setTextColor(212, 175, 55); // Gold
    pdf.text('Decision Posture Audit', pageWidth / 2, 85, { align: 'center' });

    // Decorative line
    pdf.setDrawColor(212, 175, 55);
    pdf.setLineWidth(0.5);
    pdf.line(70, 95, 140, 95);

    // Audit details box
    pdf.setFillColor(20, 20, 20);
    pdf.roundedRect(40, 110, 130, 45, 3, 3, 'F');

    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(9);
    pdf.setTextColor(212, 175, 55);
    pdf.text('AUDIT REFERENCE', pageWidth / 2, 120, { align: 'center' });

    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(10);
    pdf.setTextColor(200, 200, 200);
    pdf.text(artifact.intakeId.toUpperCase(), pageWidth / 2, 130, { align: 'center' });

    const date = new Date().toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });

    pdf.setFontSize(9);
    pdf.setTextColor(212, 175, 55);
    pdf.text('GENERATED', pageWidth / 2, 142, { align: 'center' });

    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(10);
    pdf.setTextColor(200, 200, 200);
    pdf.text(date, pageWidth / 2, 150, { align: 'center' });

    // Value proposition
    pdf.setFont('helvetica', 'italic');
    pdf.setFontSize(11);
    pdf.setTextColor(180, 180, 180);
    pdf.text('Institutional-Grade Intelligence', pageWidth / 2, 180, { align: 'center' });
    pdf.text('for Ultra-High-Net-Worth Decision Making', pageWidth / 2, 188, { align: 'center' });

    // Bottom seal
    pdf.setDrawColor(212, 175, 55);
    pdf.setLineWidth(1);
    pdf.circle(pageWidth / 2, 235, 20, 'S');

    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(8);
    pdf.setTextColor(212, 175, 55);
    pdf.text('CONFIDENTIAL', pageWidth / 2, 233, { align: 'center' });
    pdf.text('&', pageWidth / 2, 238, { align: 'center' });
    pdf.text('PROPRIETARY', pageWidth / 2, 243, { align: 'center' });

    // Footer
    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(8);
    pdf.setTextColor(100, 100, 100);
    pdf.text('HNWI Chronicles Intelligence Division', pageWidth / 2, 275, { align: 'center' });
    pdf.text('This report contains forward-looking statements. See disclaimers.', pageWidth / 2, 282, { align: 'center' });

    // Gold accent line at bottom
    pdf.setFillColor(212, 175, 55);
    pdf.rect(0, 295, pageWidth, 2, 'F');

    // ========================================================================
    // CONTENT PAGES - Capture each section individually
    // ========================================================================
    console.log('üìÑ Preparing content for export...');

    const container = document.getElementById('artifact-content');
    if (!container) {
      throw new Error('Artifact content not found');
    }

    // Temporarily switch to light mode for PDF (better for printing)
    const htmlElement = document.documentElement;
    const originalTheme = htmlElement.classList.contains('dark') ? 'dark' : 'light';

    // Force light mode for PDF export
    htmlElement.classList.remove('dark');
    htmlElement.classList.add('light');
    htmlElement.setAttribute('data-pdf-export', 'true');

    // Wait for theme transition
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Ensure all images are fully loaded
    const images = container.querySelectorAll('img');
    await Promise.all(
      Array.from(images).map(img => {
        if (img.complete) return Promise.resolve();
        return new Promise((resolve) => {
          img.onload = resolve;
          img.onerror = resolve;
        });
      })
    );

    await new Promise(resolve => setTimeout(resolve, 500));

    // Canvas options for high-quality capture
    const canvasOptions = {
      scale: 2,
      useCORS: true,
      logging: false,
      backgroundColor: '#ffffff',
      windowWidth: 1200,
      allowTaint: false,
      imageTimeout: 15000,
      removeContainer: false,
      onclone: (clonedDoc: Document) => {
        const clonedHtml = clonedDoc.documentElement;
        clonedHtml.classList.remove('dark');
        clonedHtml.classList.add('light');
        clonedHtml.setAttribute('data-theme', 'light');
      }
    };

    // Get all direct children of artifact-content (MemoHeader + sections)
    const contentElements = Array.from(container.children) as HTMLElement[];
    console.log(`üì∏ Found ${contentElements.length} content elements to capture`);

    const margin = 10;
    const imgWidth = 190;
    const usableHeight = pageHeight - (margin * 2);

    for (let i = 0; i < contentElements.length; i++) {
      const element = contentElements[i];

      // Skip if hidden
      if (!element.offsetHeight || element.offsetHeight < 10) {
        console.log(`‚è≠Ô∏è  Skipping element ${i + 1} - too small or hidden`);
        continue;
      }

      console.log(`üì∏ Capturing element ${i + 1}/${contentElements.length} - height: ${element.offsetHeight}px`);

      // Scroll into view
      element.scrollIntoView({ behavior: 'instant', block: 'nearest' });
      await new Promise(resolve => setTimeout(resolve, 200));

      // Capture this element
      const canvas = await html2canvas(element, canvasOptions);

      if (canvas.width === 0 || canvas.height === 0) {
        console.log(`‚ö†Ô∏è  Element ${i + 1} produced empty canvas`);
        continue;
      }

      console.log(`‚úÖ Element ${i + 1} captured - canvas: ${canvas.width}x${canvas.height}px`);

      const imgHeight = (canvas.height * imgWidth) / canvas.width;

      // Always start a new page for each major element
      pdf.addPage();
      pdf.setFillColor(255, 255, 255);
      pdf.rect(0, 0, pageWidth, pageHeight, 'F');

      if (imgHeight <= usableHeight) {
        // Fits on one page
        pdf.addImage(canvas.toDataURL('image/jpeg', 0.85), 'JPEG', margin, margin, imgWidth, imgHeight);
      } else {
        // Needs multiple pages
        let remainingHeight = imgHeight;
        let currentY = 0;
        let pageNum = 0;

        while (remainingHeight > 0) {
          if (pageNum > 0) {
            pdf.addPage();
            pdf.setFillColor(255, 255, 255);
            pdf.rect(0, 0, pageWidth, pageHeight, 'F');
          }

          const sourceY = pageNum * usableHeight * (canvas.height / imgHeight);
          const sourceHeight = Math.min(usableHeight * (canvas.height / imgHeight), canvas.height - sourceY);
          const displayHeight = (sourceHeight / canvas.height) * imgHeight;

          // Create a temporary canvas for this slice
          const sliceCanvas = document.createElement('canvas');
          sliceCanvas.width = canvas.width;
          sliceCanvas.height = sourceHeight;
          const sliceCtx = sliceCanvas.getContext('2d');

          if (sliceCtx) {
            sliceCtx.drawImage(canvas, 0, sourceY, canvas.width, sourceHeight, 0, 0, canvas.width, sourceHeight);
            pdf.addImage(sliceCanvas.toDataURL('image/jpeg', 0.85), 'JPEG', margin, margin, imgWidth, displayHeight);
          }

          remainingHeight -= displayHeight;
          pageNum++;
        }
      }
    }

    // ========================================================================
    // PREMIUM DISCLAIMER PAGE
    // ========================================================================
    console.log('üìÑ Adding premium disclaimer page...');

    pdf.addPage();

    // Subtle gradient background (light gray)
    pdf.setFillColor(250, 250, 250);
    pdf.rect(0, 0, pageWidth, pageHeight, 'F');

    // Gold accent bar at top
    pdf.setFillColor(212, 175, 55);
    pdf.rect(0, 0, pageWidth, 3, 'F');

    // Title section
    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(18);
    pdf.setTextColor(0, 0, 0);
    pdf.text('Important Disclosures', pageWidth / 2, 25, { align: 'center' });

    // Decorative line
    pdf.setDrawColor(212, 175, 55);
    pdf.setLineWidth(0.3);
    pdf.line(70, 30, 140, 30);

    const disclaimers = [
      {
        title: 'NOT FINANCIAL ADVICE',
        text: 'This Decision Posture Audit is for informational and strategic planning purposes only. It does not constitute financial, legal, tax, or investment advice. All decisions should be made in consultation with qualified professionals licensed in your jurisdiction.'
      },
      {
        title: 'FORWARD-LOOKING STATEMENTS',
        text: 'This report contains forward-looking projections based on current market conditions, historical data, and peer cohort analysis. Actual results may differ materially from projections. Past performance does not guarantee future results.'
      },
      {
        title: 'JURISDICTION-SPECIFIC COMPLIANCE',
        text: 'Tax rates, regulatory requirements, and compliance obligations vary significantly by jurisdiction and change frequently. All information must be verified with local authorities and qualified advisors before implementation.'
      },
      {
        title: 'RISK ACKNOWLEDGMENT',
        text: 'All cross-border transactions and investment decisions carry inherent risks, including but not limited to: regulatory changes, currency fluctuations, market volatility, liquidity constraints, and potential loss of capital.'
      },
      {
        title: 'CONFIDENTIALITY & PROPRIETARY ANALYSIS',
        text: 'This report contains confidential and proprietary intelligence generated by HNWI Chronicles. It is intended solely for the named recipient. Unauthorized reproduction, distribution, or disclosure is strictly prohibited and may violate applicable laws.'
      },
      {
        title: 'DATA SOURCES & METHODOLOGY',
        text: 'Analysis is derived from KGv3 Regulatory Intelligence, peer cohort tracking, historical precedent analysis, and institutional research. While we maintain rigorous data standards, we cannot guarantee absolute accuracy or completeness.'
      },
      {
        title: 'NO GUARANTEES',
        text: 'HNWI Chronicles makes no warranties or guarantees regarding the outcomes of any strategies discussed in this report. Economic conditions, regulatory environments, and market dynamics are subject to rapid and unpredictable change.'
      }
    ];

    let yPos = 42;
    const leftMargin = 20;
    const rightMargin = 20;
    const textWidth = pageWidth - leftMargin - rightMargin;

    disclaimers.forEach((disclaimer, index) => {
      // Title box
      pdf.setFillColor(0, 0, 0);
      pdf.rect(leftMargin, yPos - 4, textWidth, 6, 'F');

      pdf.setFont('helvetica', 'bold');
      pdf.setFontSize(8);
      pdf.setTextColor(212, 175, 55);
      pdf.text(disclaimer.title, leftMargin + 2, yPos);

      yPos += 8;

      // Content
      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.setTextColor(40, 40, 40);
      const lines = pdf.splitTextToSize(disclaimer.text, textWidth - 4);
      pdf.text(lines, leftMargin + 2, yPos);

      yPos += lines.length * 3.5 + 6;
    });

    // Bottom section
    pdf.setDrawColor(212, 175, 55);
    pdf.setLineWidth(0.3);
    pdf.line(leftMargin, 260, pageWidth - rightMargin, 260);

    pdf.setFont('helvetica', 'bold');
    pdf.setFontSize(9);
    pdf.setTextColor(0, 0, 0);
    pdf.text('HNWI Chronicles Intelligence Division', pageWidth / 2, 268, { align: 'center' });

    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(8);
    pdf.setTextColor(100, 100, 100);
    pdf.text('Institutional-Grade Intelligence for Ultra-High-Net-Worth Decision Making', pageWidth / 2, 274, { align: 'center' });

    pdf.setFontSize(7);
    pdf.text('¬© 2026 HNWI Chronicles. All rights reserved. Confidential and proprietary.', pageWidth / 2, 282, { align: 'center' });
    pdf.text('For inquiries: intelligence@hnwichronicles.com', pageWidth / 2, 287, { align: 'center' });

    // Gold accent bar at bottom
    pdf.setFillColor(212, 175, 55);
    pdf.rect(0, 294, pageWidth, 3, 'F');

    // ========================================================================
    // PREMIUM PAGE NUMBERS
    // ========================================================================
    const totalPages = pdf.getNumberOfPages();
    const contentPages = totalPages - 2; // Exclude cover and disclaimer
    console.log(`üìÑ Adding premium page numbers to ${totalPages} pages (${contentPages} content pages)...`);

    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);

      // Skip page numbers on cover page
      if (i === 1) continue;

      // Add subtle footer line
      pdf.setDrawColor(230, 230, 230);
      pdf.setLineWidth(0.2);
      pdf.line(20, 285, pageWidth - 20, 285);

      pdf.setFont('helvetica', 'normal');
      pdf.setFontSize(8);
      pdf.setTextColor(120, 120, 120);

      if (i === totalPages) {
        // Disclaimer page - special footer
        pdf.text('CONFIDENTIAL', 20, 291);
        pdf.text('Disclaimers', pageWidth - 20, 291, { align: 'right' });
      } else {
        // Content pages
        pdf.text('HNWI Chronicles', 20, 291);
        pdf.text(`Page ${i - 1} of ${contentPages}`, pageWidth - 20, 291, { align: 'right' });
      }
    }

    // ========================================================================
    // FINALIZE & SAVE
    // ========================================================================

    // Restore original theme and scroll position
    window.scrollTo({ top: 0, behavior: 'instant' });
    htmlElement.removeAttribute('data-pdf-export');
    if (originalTheme === 'dark') {
      htmlElement.classList.remove('light');
      htmlElement.classList.add('dark');
    }

    const fileName = `HNWI-Decision-Audit-${artifact.intakeId.slice(10, 22)}.pdf`;
    console.log(`‚úÖ PDF GENERATION COMPLETE!`);
    console.log(`üìÑ File: ${fileName}`);
    console.log(`üìä Structure: ${totalPages} total pages`);
    console.log(`   ‚Ä¢ Cover page (premium black/gold design)`);
    console.log(`   ‚Ä¢ ${contentPages} content pages (all sections captured)`);
    console.log(`   ‚Ä¢ Disclaimer page (premium disclosures)`);
    console.log(`üíæ File size: Optimized with JPEG 85% compression`);

    pdf.save(fileName);
  }, []);

  // ==========================================================================
  // SHARE ARTIFACT
  // Generate shareable link or send to advisor
  // ==========================================================================

  const shareArtifact = useCallback(async (
    intakeId: string,
    options: { email?: string; copyLink?: boolean }
  ): Promise<{ shareUrl: string }> => {
    const response = await fetch(`${API_BASE}/share`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        intake_id: intakeId,
        advisor_email: options.email
      })
    });

    if (!response.ok) {
      throw new Error('Sharing failed');
    }

    const data = await response.json();

    if (options.copyLink && data.share_url) {
      await navigator.clipboard.writeText(data.share_url);
    }

    return { shareUrl: data.share_url };
  }, []);

  return {
    submitIntake,
    getSession,
    getPreviewArtifact,
    generateAudit,
    // Payment methods
    createPaymentOrder,
    initiatePayment,
    verifyPayment,
    checkPaymentStatus,
    openPaymentCheckout,
    // Artifact methods
    getFullArtifact,
    exportPDF,
    shareArtifact
  };
}

// =============================================================================
// TRANSFORM FUNCTIONS
// =============================================================================

function transformIntakeToAPI(intake: SFOPatternAuditIntake): PatternAuditAPIPayload {
  return {
    thesis: {
      move_description: intake.thesis.moveDescription,
      expected_outcome: intake.thesis.expectedOutcome,
      move_type: intake.thesis.moveType,
      target_amount: intake.thesis.targetAmount,
      target_locations: intake.thesis.targetLocations,
      timeline: intake.thesis.timeline
    },
    constraints: {
      liquidity_horizon: intake.constraints.liquidityHorizon,
      liquidity_amount_needed: intake.constraints.liquidityAmountNeeded,
      liquidity_events: intake.constraints.liquidityEvents,
      current_jurisdictions: intake.constraints.currentJurisdictions,
      prohibited_jurisdictions: intake.constraints.prohibitedJurisdictions,
      prohibitions: intake.constraints.prohibitions,
      deal_breakers: intake.constraints.dealBreakers
    },
    control_and_rails: {
      final_decision_maker: intake.controlAndRails.finalDecisionMaker,
      decision_makers_count: intake.controlAndRails.decisionMakersCount,
      veto_holders: intake.controlAndRails.vetoHolders,
      approval_required_above: intake.controlAndRails.approvalRequiredAbove,
      advisors: intake.controlAndRails.advisors.map(a => ({
        type: a.type,
        name: a.name,
        jurisdiction: a.jurisdiction
      })),
      existing_entities: intake.controlAndRails.existingEntities.map(e => ({
        type: e.type,
        jurisdiction: e.jurisdiction,
        purpose: e.purpose
      })),
      banking_rails: intake.controlAndRails.bankingRails.map(b => ({
        bank: b.bank,
        jurisdiction: b.jurisdiction,
        status: b.status
      })),
      has_formal_ips: intake.controlAndRails.hasFormalIPS,
      ips_notes: intake.controlAndRails.ipsNotes
    },
    urgency: intake.urgency
  };
}

function transformSessionFromAPI(data: any): AuditSession & { fullArtifact?: ICArtifact; preview_data?: any; memo_data?: any } {
  // Map backend status to frontend status
  // Backend may return: SUBMITTED, IN_REVIEW, PREVIEW_READY, PAID, FULL_READY
  const status = data.status || data.payment_status || 'PREVIEW_READY';

  // Check if paid/unlocked - backend might use different field names
  const isPaid = data.is_paid || data.paid || data.is_unlocked || status === 'PAID' || status === 'FULL_READY';

  const session: AuditSession & { fullArtifact?: ICArtifact; preview_data?: any; memo_data?: any } = {
    intakeId: data.intake_id,
    principalId: 'sfo_audit',
    status: isPaid ? 'PAID' : status,
    submittedAt: data.generated_at || data.submitted_at,
    previewReadyAt: data.generated_at || data.preview_ready_at,
    paidAt: data.paid_at,
    fullReadyAt: data.full_ready_at,
    previewUrl: `/decision-memo/audit/${data.intake_id}`,
    expiresAt: data.expires_at || '',
    price: data.price || 2500,
    unlockAt: data.unlock_at,
    isUnlocked: data.is_unlocked || isPaid || false
  };

  // If session includes full_artifact (from unlocked state), transform and include it
  if (data.full_artifact) {
    session.fullArtifact = transformArtifactFromAPI(data.full_artifact);
  }

  // Pass through preview_data and memo_data for peer cohort stats, capital flow data
  // These are generated by the session API route for unlocked sessions
  if (data.preview_data) {
    session.preview_data = data.preview_data;
  }
  if (data.memo_data) {
    session.memo_data = data.memo_data;
  }

  return session;
}

function transformPreviewFromAPI(data: any): PreviewArtifact {
  // Handle both old backend format (flat arrays) and new format (structured *_preview objects)
  const hasNewFormat = data.sequence_preview || data.failure_modes_preview;

  // Build sequence_preview from old format if needed
  const sequencePreview = data.sequence_preview || (data.sequence_titles?.length ? {
    total_steps: data.sequence_titles.length,
    first_step: data.sequence_titles[0],
    implied_vs_corrected: true,
    message: data.why_this_matters || 'Sequence has been optimized for execution.'
  } : undefined);

  // Build failure_modes_preview from old format if needed
  const failureModesPreview = data.failure_modes_preview || (data.failure_mode_titles?.length ? {
    count: data.failure_mode_titles.length,
    triggers: data.failure_mode_titles,
    has_governance_failure: data.failure_mode_titles.some((t: string) =>
      t.toLowerCase().includes('governance') || t.toLowerCase().includes('entity') || t.toLowerCase().includes('structure')
    ),
    has_economic_failure: data.failure_mode_titles.some((t: string) =>
      t.toLowerCase().includes('economic') || t.toLowerCase().includes('timing') || t.toLowerCase().includes('liquidity')
    ),
    message: 'Mechanism-driven failure modes identified with mitigation strategies.'
  } : undefined);

  // Build pattern_anchors_preview from old format if needed
  const patternAnchorsPreview = data.pattern_anchors_preview || (data.pattern_anchor_titles?.length ? {
    count: data.pattern_anchor_titles.length,
    pattern_names: data.pattern_anchor_titles,
    message: 'Historical patterns matched from intelligence library.'
  } : undefined);

  // Build next_step_preview from old format if needed
  const nextStepPreview = data.next_step_preview || (data.next_action_headline ? {
    action_headline: data.next_action_headline,
    timeline: '7-14 days',
    message: 'Critical path item that unlocks subsequent steps.'
  } : undefined);

  // Build intelligence_preview from old format if needed
  const intelligencePreview = data.intelligence_preview || (data.intelligence_sources ? {
    developments_analyzed: data.intelligence_sources.precedents_reviewed || 0,
    regulatory_patterns: data.intelligence_sources.regulatory_anchors || 0,
    failure_modes_identified: data.intelligence_sources.failure_modes || 0,
    message: `Analysis based on ${data.intelligence_sources.precedents_reviewed || 0} precedents and ${data.intelligence_sources.sequence_corrections || 0} sequence corrections.`
  } : undefined);

  // Build scope_preview (may not exist in old format)
  const scopePreview = data.scope_preview || {
    valid_until: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 90 days
    in_scope_count: 5,
    out_of_scope_count: 3
  };

  // Build call_to_action from old format if needed
  const callToAction = data.call_to_action || {
    headline: 'Unlock Full IC Artifact',
    subheadline: 'Get complete sequence, failure mechanisms, and pattern analysis',
    button_text: `Unlock for ${data.price_display || '$2,500'}`,
    payment_url: `/api/decision-memo/payment/${data.intake_id}`
  };

  return {
    intakeId: data.intake_id || '',
    principalId: 'sfo_audit',
    thesisSummary: data.thesis_summary,
    generatedAt: data.generated_at || new Date().toISOString(),
    status: 'PREVIEW_READY',

    verdict: {
      verdict: data.verdict?.verdict || 'PROCEED WITH MODIFICATIONS',
      // Handle both old (single_sentence) and new (single_sentence_preview) field names
      singleSentence: data.verdict?.single_sentence_preview || data.verdict?.single_sentence || '',
      thesisSurvives: data.verdict?.thesis_survives ?? true
    },
    whyThisMatters: data.why_this_matters || sequencePreview?.message || 'This decision requires careful sequencing.',

    // Legacy array fields (for backwards compatibility)
    sequenceTitles: data.sequence_titles || (sequencePreview?.first_step
      ? [`${sequencePreview.first_step} (+${(sequencePreview.total_steps || 1) - 1} more steps)`]
      : []),
    failureModeTitles: data.failure_mode_titles || failureModesPreview?.triggers || [],
    patternAnchorTitles: data.pattern_anchor_titles || patternAnchorsPreview?.pattern_names || [],
    nextActionHeadline: data.next_action_headline || nextStepPreview?.action_headline || '',
    lockedSections: data.locked_sections || ['Full sequence details', 'Failure mechanisms', 'Pattern analysis', 'PDF export'],

    price: data.price || 2500,
    priceDisplay: data.price_display || '$2,500',

    intelligenceSources: {
      developmentsMatched: intelligencePreview?.developments_analyzed || data.intelligence_sources?.precedents_reviewed || 0,
      failurePatternsMatched: intelligencePreview?.failure_modes_identified || data.intelligence_sources?.failure_modes || 0,
      sequencingRulesApplied: intelligencePreview?.regulatory_patterns || data.intelligence_sources?.regulatory_anchors || 0
    },

    // Structured preview data (built from either format)
    sequencePreview,
    failureModesPreview,
    patternAnchorsPreview,
    nextStepPreview,
    scopePreview,
    intelligencePreview,
    callToAction
  };
}

function transformArtifactFromAPI(data: any): ICArtifact {
  // Handle new backend format (preview_data + memo_data at top level)
  // vs old format (artifact fields at top level)
  const hasNewFormat = data.preview_data && data.memo_data;

  // Extract intelligence sources from correct location
  // New format: data.memo_data.kgv3_intelligence_used
  // Old format: data.intelligence_sources
  const kgv3Intel = data.memo_data?.kgv3_intelligence_used || {};
  const oldIntel = data.intelligence_sources || {};

  console.log('üìä [transformArtifact] Format:', hasNewFormat ? 'NEW (preview_data/memo_data)' : 'OLD (flat)');
  console.log('üìä [transformArtifact] kgv3_intelligence_used:', kgv3Intel);

  return {
    intakeId: data.intake_id,
    principalId: data.principal_id || 'sfo_audit',
    thesisSummary: data.thesis_summary || '',
    generatedAt: data.generated_at || data.memo_data?.generated_at || new Date().toISOString(),
    status: 'FULL_READY',

    verdict: data.verdict ? {
      verdict: data.verdict.verdict,
      singleSentence: data.verdict.single_sentence,
      thesisSurvives: data.verdict.thesis_survives
    } : {
      verdict: 'PROCEED WITH MODIFICATIONS',
      singleSentence: '',
      thesisSurvives: true
    },
    whyThisMatters: data.why_this_matters || '',

    sequence: (data.sequence || []).map((s: any) => ({
      order: s.order,
      action: s.action,
      owner: s.owner,
      timeline: s.timeline,
      whyThisOrder: s.why_this_order
    })),

    failureModes: (data.failure_modes || []).map((m: any) => ({
      trigger: m.trigger,
      mechanism: m.mechanism,
      damage: m.damage,
      mitigation: m.mitigation
    })),

    patternAnchors: (data.pattern_anchors || []).map((a: any) => ({
      patternName: a.pattern_name,
      patternClass: a.pattern_class,
      historicalBehavior: a.historical_behavior,
      confidence: a.confidence
    })),

    nextStep: {
      action: data.next_step?.action || '',
      executor: data.next_step?.executor || '',
      timeline: data.next_step?.timeline || '',
      unlocks: data.next_step?.unlocks || '',
      ifBlocked: data.next_step?.if_blocked || ''
    },

    scope: {
      inScope: data.scope?.in_scope || [],
      outOfScope: data.scope?.out_of_scope || [],
      validUntil: data.scope?.valid_until || ''
    },

    // Intelligence sources - handle both new and old formats
    // New format: memo_data.kgv3_intelligence_used.precedents/failure_modes/sequencing_rules
    // Old format: intelligence_sources.developments_matched/precedents_reviewed
    intelligenceSources: {
      developmentsMatched: kgv3Intel.precedents || oldIntel.developments_matched || oldIntel.precedents_reviewed || 0,
      failurePatternsMatched: kgv3Intel.failure_modes || oldIntel.failure_patterns_matched || oldIntel.failure_modes || 0,
      sequencingRulesApplied: kgv3Intel.sequencing_rules || oldIntel.sequencing_rules_applied || oldIntel.sequence_corrections || 0
    },

    // SOTA Components (Harvard/Stanford OG Standard)
    impliedIps: data.implied_ips ? {
      primaryObjective: data.implied_ips.primary_objective || '',
      secondaryObjectives: data.implied_ips.secondary_objectives || [],
      riskTolerance: data.implied_ips.risk_tolerance || '',
      riskCapacity: data.implied_ips.risk_capacity || '',
      volatilityTolerance: data.implied_ips.volatility_tolerance || '',
      liquidityHorizon: data.implied_ips.liquidity_horizon || '',
      minimumLiquidBuffer: data.implied_ips.minimum_liquid_buffer || '',
      liquidityConstraints: data.implied_ips.liquidity_constraints || [],
      maxSinglePositionPct: data.implied_ips.max_single_position_pct || 25,
      maxSingleJurisdictionPct: data.implied_ips.max_single_jurisdiction_pct || 50,
      maxIlliquidPct: data.implied_ips.max_illiquid_pct || 40,
      currentConcentrationRisk: data.implied_ips.current_concentration_risk || '',
      assetClassTargets: data.implied_ips.asset_class_targets || {},
      geographicTargets: data.implied_ips.geographic_targets || {},
      prohibitedInvestments: data.implied_ips.prohibited_investments || [],
      restrictedInvestments: data.implied_ips.restricted_investments || [],
      investmentHorizon: data.implied_ips.investment_horizon || '',
      reviewFrequency: data.implied_ips.review_frequency || 'Quarterly',
      decisionAuthority: data.implied_ips.decision_authority || '',
      approvalThresholds: data.implied_ips.approval_thresholds || {},
      taxOptimizationPriority: data.implied_ips.tax_optimization_priority || '',
      preferredStructures: data.implied_ips.preferred_structures || [],
      taxJurisdictions: data.implied_ips.tax_jurisdictions || [],
      confidenceScore: data.implied_ips.confidence_score || 0,
      missingDataPoints: data.implied_ips.missing_data_points || []
    } : null,

    returnScenarios: data.return_scenarios ? {
      baseCase: {
        name: data.return_scenarios.base_case?.name || 'Base Case',
        probability: data.return_scenarios.base_case?.probability || 0.6,
        annualReturnPct: data.return_scenarios.base_case?.annual_return_pct || '',
        irrEstimate: data.return_scenarios.base_case?.irr_estimate,
        moicEstimate: data.return_scenarios.base_case?.moic_estimate,
        annualTaxSavings: data.return_scenarios.base_case?.annual_tax_savings || '',
        totalTaxSavings: data.return_scenarios.base_case?.total_tax_savings || '',
        totalValueCreation: data.return_scenarios.base_case?.total_value_creation || '',
        exitTimeline: data.return_scenarios.base_case?.exit_timeline || '',
        exitMethod: data.return_scenarios.base_case?.exit_method || '',
        exitHaircut: data.return_scenarios.base_case?.exit_haircut || '',
        assumptions: data.return_scenarios.base_case?.assumptions || []
      },
      bullCase: {
        name: data.return_scenarios.bull_case?.name || 'Bull Case',
        probability: data.return_scenarios.bull_case?.probability || 0.25,
        annualReturnPct: data.return_scenarios.bull_case?.annual_return_pct || '',
        irrEstimate: data.return_scenarios.bull_case?.irr_estimate,
        moicEstimate: data.return_scenarios.bull_case?.moic_estimate,
        totalValueCreation: data.return_scenarios.bull_case?.total_value_creation || '',
        exitTimeline: data.return_scenarios.bull_case?.exit_timeline || '',
        exitMethod: data.return_scenarios.bull_case?.exit_method || '',
        assumptions: data.return_scenarios.bull_case?.assumptions || []
      },
      bearCase: {
        name: data.return_scenarios.bear_case?.name || 'Bear Case',
        probability: data.return_scenarios.bear_case?.probability || 0.15,
        annualReturnPct: data.return_scenarios.bear_case?.annual_return_pct || '',
        irrEstimate: data.return_scenarios.bear_case?.irr_estimate,
        moicEstimate: data.return_scenarios.bear_case?.moic_estimate,
        totalValueCreation: data.return_scenarios.bear_case?.total_value_creation || '',
        exitTimeline: data.return_scenarios.bear_case?.exit_timeline || '',
        exitMethod: data.return_scenarios.bear_case?.exit_method || '',
        exitHaircut: data.return_scenarios.bear_case?.exit_haircut || '',
        assumptions: data.return_scenarios.bear_case?.assumptions || []
      },
      expectedValue: data.return_scenarios.expected_value || '',
      riskRewardAssessment: data.return_scenarios.risk_reward_assessment || '',
      keySensitivities: data.return_scenarios.key_sensitivities || []
    } : null,

    ddChecklist: data.dd_checklist ? {
      moveType: data.dd_checklist.move_type || '',
      totalItems: data.dd_checklist.total_items || 0,
      completedItems: data.dd_checklist.completed_items || 0,
      highPriorityItems: data.dd_checklist.high_priority_items || 0,
      jurisdictionsCovered: data.dd_checklist.jurisdictions_covered || [],
      assetClassesCovered: data.dd_checklist.asset_classes_covered || [],
      items: (data.dd_checklist.items || []).map((item: any) => ({
        category: item.category || '',
        item: item.item || '',
        status: item.status || 'pending',
        owner: item.owner || '',
        notes: item.notes || '',
        priority: item.priority || 'medium'
      }))
    } : null,

    alternativesConsidered: (data.alternatives_considered || []).map((alt: any) => ({
      alternative: alt.alternative || '',
      whyNotSelected: alt.why_not_selected || '',
      comparativeMetrics: alt.comparative_metrics || {}
    })),

    // Deal overview with jurisdiction info
    dealOverview: data.deal_overview ? {
      moveType: data.deal_overview.move_type || '',
      targetSize: data.deal_overview.target_size || '',
      jurisdictions: data.deal_overview.jurisdictions || '',
      timeline: data.deal_overview.timeline || '',
      riskPool: data.deal_overview.risk_pool || '',
      financing: data.deal_overview.financing || '',
      holdPeriod: data.deal_overview.hold_period || ''
    } : null,

    // Investment thesis
    investmentThesis: data.investment_thesis ? {
      whyMakesSense: data.investment_thesis.why_makes_sense || [],
      hiddenRisks: data.investment_thesis.hidden_risks || []
    } : null,

    // Rich verdict for executive summary
    richVerdict: data.rich_verdict ? {
      whatTheyThinkSafe: data.rich_verdict.what_they_think_safe || '',
      whatIsFragile: data.rich_verdict.what_is_fragile || '',
      whyFragile: data.rich_verdict.why_fragile || '',
      consequenceIfUnchanged: data.rich_verdict.consequence_if_unchanged || '',
      correctSequence: data.rich_verdict.correct_sequence || ''
    } : null,

    // Stop list
    stopList: (data.stop_list || []).map((item: any) => ({
      number: item.number || 0,
      stopAction: item.stop_action || '',
      untilCondition: item.until_condition || ''
    })),

    // Matched opportunities
    matchedOpportunities: (data.matched_opportunities || []).map((opp: any) => ({
      title: opp.title || '',
      whyRelevant: opp.why_relevant || '',
      timing: opp.timing || '',
      opportunityId: opp.opportunity_id || ''
    })),

    shareableUrl: data.shareable_url || '',
    pdfUrl: data.pdf_url || ''
  };
}

export default usePatternAudit;
