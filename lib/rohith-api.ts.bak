// lib/rohith-api.ts
// API service layer for Ask Rohith feature with SOTA Graph integration

import { secureApi } from "@/lib/secure-api"
import { getCurrentUserId } from "@/lib/auth-manager"
import { getCrownVaultAssets, getCrownVaultStats } from "@/lib/api"
import type {
  UserPortfolioContext,
  UserContextResponse,
  Conversation,
  ConversationWithMessages,
  ConversationResponse,
  ConversationListResponse,
  CreateConversationRequest,
  SendMessageRequest,
  SystemStatus,
  Message
} from "@/types/rohith"

/**
 * API service for Rohith - Private intelligence ally with conversation management
 * Integrates with SOTA Graph backend and HNWI Knowledge Base for personalized context and memory
 */
export class RohithAPI {
  private static instance: RohithAPI
  private userContextCache: Map<string, { data: UserPortfolioContext; timestamp: number }> = new Map()
  private readonly CACHE_DURATION = 10 * 60 * 1000 // 10 minutes

  private constructor() {}

  public static getInstance(): RohithAPI {
    if (!RohithAPI.instance) {
      RohithAPI.instance = new RohithAPI()
    }
    return RohithAPI.instance
  }

  /**
   * Load user context including portfolio, preferences, and market intelligence
   */
  async loadUserContext(userId?: string): Promise<UserPortfolioContext> {
    try {
      const targetUserId = userId || getCurrentUserId()
      if (!targetUserId) {
        throw new Error("User ID not found")
      }

      // Check cache first
      const cached = this.userContextCache.get(targetUserId)
      if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
        return cached.data
      }

      // For now, load from existing Crown Vault and user APIs until SOTA Graph is ready
      const [crownVaultStats, crownVaultAssets, userProfile] = await Promise.all([
        getCrownVaultStats().catch(() => null),
        getCrownVaultAssets().catch(() => []),
        secureApi.get(`/api/users/${targetUserId}`, true, { enableCache: true, cacheDuration: 600000 }).catch(() => null)
      ])

      // Calculate portfolio metrics from Crown Vault data
      const assets = Array.isArray(crownVaultAssets) ? crownVaultAssets : []
      const stats = crownVaultStats || {}


      const totalValue = stats.total_value || assets.reduce((sum: number, asset: any) => sum + (asset.asset_data?.value || 0), 0)
      const realEstateAssets = assets.filter((asset: any) => asset.asset_data?.asset_type === 'Real Estate')
      const preciousMetalsAssets = assets.filter((asset: any) => asset.asset_data?.asset_type === 'Precious Metals')

      const realEstateValue = realEstateAssets.reduce((sum: number, asset: any) => sum + (asset.asset_data?.value || 0), 0)
      const preciousMetalsValue = preciousMetalsAssets.reduce((sum: number, asset: any) => sum + (asset.asset_data?.value || 0), 0)

      const userContext: UserPortfolioContext = {
        userId: targetUserId,
        portfolio: {
          totalValue: totalValue > 0 ? `$${(totalValue / 1000000).toFixed(2)}M` : "$0",
          totalAssets: assets.length,
          realEstateHoldings: "0", // Hidden from UI
          preciousMetalsPosition: "0", // Hidden from UI
          marketIntelligenceReports: stats.intelligence_reports || 12 // Default to 12 for demo
        },
        personalDetails: {
          name: userProfile?.name || userProfile?.first_name || "User",
          email: userProfile?.email || "",
          location: userProfile?.location
        },
        preferences: {
          riskTolerance: userProfile?.risk_tolerance,
          investmentFocus: userProfile?.investment_focus ? [userProfile.investment_focus] : ["Real Estate", "Precious Metals"],
          communicationStyle: "professional"
        }
      }

      // Cache the result
      this.userContextCache.set(targetUserId, {
        data: userContext,
        timestamp: Date.now()
      })

      return userContext
    } catch (error) {
      // Return minimal context on error
      const userId = getCurrentUserId() || "unknown"
      return {
        userId,
        portfolio: {
          totalValue: "0",
          totalAssets: 0,
          realEstateHoldings: "0",
          preciousMetalsPosition: "0",
          marketIntelligenceReports: 0
        },
        personalDetails: {
          name: "User",
          email: ""
        },
        preferences: {}
      }
    }
  }

  /**
   * Get all conversations for a user
   */
  async getConversations(userId?: string): Promise<Conversation[]> {
    try {
      const targetUserId = userId || getCurrentUserId()
      if (!targetUserId) {
        throw new Error("User ID not found")
      }


      const response = await secureApi.get(
        `/api/rohith/conversations`,
        true,
        { enableCache: false } // Disable cache for debugging
      )


      // Handle different response formats from the Rohith API
      let conversationsData = response

      // Check if response is wrapped in an object
      if (response && !Array.isArray(response)) {
        if (response.conversations && Array.isArray(response.conversations)) {
          conversationsData = response.conversations
        } else if (response.data && Array.isArray(response.data)) {
          conversationsData = response.data
        } else {
          // If no array found, return empty array
          return []
        }
      }

      // Ensure we have an array
      if (!Array.isArray(conversationsData)) {
        return []
      }

      // Transform the response to match our frontend format
      const conversations: Conversation[] = conversationsData.map((conv: any) => ({
        id: conv.conversation_id || conv.id,
        title: conv.title || conv.preview || "New Conversation",
        userId: targetUserId,
        createdAt: new Date(conv.created_at || Date.now()),
        updatedAt: new Date(conv.last_activity || conv.updated_at || Date.now()),
        lastMessage: conv.preview || conv.last_message || "",
        messageCount: conv.message_count || 0,
        isActive: true
      }))

      return conversations
    } catch (error) {
      return []
    }
  }

  /**
   * Get a specific conversation with all messages
   */
  async getConversationHistory(conversationId: string): Promise<ConversationWithMessages | null> {
    try {
      const response = await secureApi.get(
        `/api/rohith/history/${conversationId}`,
        true,
        { enableCache: true, cacheDuration: 60000 } // 1 minute cache for active conversations
      )

      // Transform the response to match our frontend format
      const messages: Message[] = response.messages?.map((msg: any) => ({
        id: msg.id || crypto.randomUUID(),
        role: msg.role === "assistant" ? "assistant" : "user",
        content: msg.content || msg.message || "",
        timestamp: new Date(msg.timestamp), // Full ISO format timestamp
        messageId: msg.message_id, // Include backend message ID for feedback
        context: msg.role === "assistant" ? {
          hnwiKnowledgeSources: ["rohith_api"],
          responseTime: msg.response_time || 3000
        } : undefined
      })) || []

      const conversationData: ConversationWithMessages = {
        id: conversationId,
        title: response.title || "Conversation",
        userId: getCurrentUserId() || "",
        createdAt: new Date(response.created_at || Date.now()),
        updatedAt: new Date(response.updated_at || Date.now()),
        messageCount: messages.length,
        isActive: true,
        messages: messages
      }

      return conversationData
    } catch (error) {
      return null
    }
  }

  /**
   * Create a new conversation
   */
  async createConversation(firstMessage: string, userId?: string): Promise<string> {
    try {
      const targetUserId = userId || getCurrentUserId()
      if (!targetUserId) {
        throw new Error("User ID not found")
      }


      // Use the Rohith start endpoint with the first message
      const response = await secureApi.post(
        "/api/rohith/start",
        {
          initial_message: firstMessage,
          user_id: targetUserId
        },
        true,
        {
          headers: {
            'Content-Type': 'application/json'
          }
        }
      )


      return response.conversation_id
    } catch (error) {
      throw error
    }
  }

  /**
   * Send a message to Rohith and get response
   */
  async sendMessage(
    message: string,
    conversationId: string,
    userId?: string
  ): Promise<ConversationResponse> {
    try {
      const targetUserId = userId || getCurrentUserId()
      if (!targetUserId) {
        throw new Error("User ID not found")
      }


      // Clear conversation cache to ensure fresh data
      this.clearConversationCache(conversationId)

      const startTime = Date.now()

      // Send message to the Rohith message endpoint
      const response = await secureApi.post(
        `/api/rohith/message/${conversationId}`,
        {
          message: message,
          user_id: targetUserId
        },
        true,
        {
          headers: {
            'Content-Type': 'application/json'
          }
        }
      )


      const responseTime = Date.now() - startTime

      // Transform the response to match our frontend format
      // Handle case where response.response might be an object with content property
      let responseText = "I'm sorry, I couldn't process that request."
      if (response.response) {
        if (typeof response.response === 'string') {
          responseText = response.response
        } else if (typeof response.response === 'object' && response.response.content) {
          responseText = response.response.content
        }
      } else if (response.message) {
        responseText = response.message
      } else if (response.content) {
        responseText = response.content
      }

      const conversationResponse: ConversationResponse = {
        response: responseText,
        conversationId,
        message_id: response.message_id, // Include message_id for feedback
        authenticity_guarantee: response.authenticity_guarantee || true,
        response_time: response.response?.processing_time_ms || responseTime,
        provenance: {
          source_nodes: response.context?.relevant_entities?.map((e: any) => e.name) || ["rohith_api"],
          knowledge_sources: response.context?.metadata?.entities_found || 0
        },
        context_used: {
          portfolio_data: true,
          conversation_history: true,
          market_intelligence: true
        }
      }

      return conversationResponse
    } catch (error) {
      throw error
    }
  }


  /**
   * Delete a conversation
   */
  async deleteConversation(conversationId: string): Promise<boolean> {
    try {
      const response = await secureApi.delete(
        `/api/rohith/history/${conversationId}`,
        true
      )

      // Clear cache
      this.clearConversationCache(conversationId)

      return response.success === true
    } catch (error) {
      return false
    }
  }

  /**
   * Update conversation title
   */
  async updateConversationTitle(conversationId: string, newTitle: string): Promise<boolean> {
    try {
      const response = await secureApi.put(
        `/api/rohith/history/${conversationId}/title`,
        {
          title: newTitle
        },
        true,
        {
          headers: {
            'Content-Type': 'application/json'
          }
        }
      )

      // Clear cache to refresh data
      this.clearConversationCache(conversationId)

      return response.success === true
    } catch (error) {
      return false
    }
  }

  /**
   * Submit feedback for a message
   */
  async submitFeedback(
    conversationId: string,
    messageId: string,
    isPositive: boolean,
    userId?: string
  ): Promise<{ success: boolean; message: string; learning_stats?: any }> {
    try {
      const targetUserId = userId || getCurrentUserId()

      const data = await secureApi.post(
        `/api/rohith/feedback/${conversationId}`,
        {
          conversation_id: conversationId,
          message_id: messageId,
          feedback_score: isPositive ? 1 : 0,
          user_id: targetUserId
        },
        true,
        {
          headers: {
            'Content-Type': 'application/json'
          }
        }
      )

      return data
    } catch (error) {
      throw error
    }
  }

  /**
   * Share a conversation
   */
  async shareConversation(conversationId: string): Promise<{ shareUrl: string; shareId: string }> {
    try {
      // Get the current conversation data
      const userId = getCurrentUserId()

      // Try to get conversation data - we'll send what we can
      let conversationData = null
      try {
        // Check cache if available
        if (this.conversationCache && this.conversationCache.has(conversationId)) {
          conversationData = this.conversationCache.get(conversationId)
        } else {
          // Try to fetch from API
          conversationData = await this.getConversation(conversationId, userId)
        }
      } catch (err) {
      }

      // First try the new MongoDB-backed endpoint
      const response = await fetch('/api/conversations/share', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ conversationId, userId, conversationData })
      })

      if (response.ok) {
        const data = await response.json()
        return {
          shareUrl: data.shareUrl,
          shareId: data.shareId
        }
      }

      // Fallback to the original endpoint if the new one fails
      const fallbackResponse = await secureApi.post(
        "/api/rohith/share",
        { conversationId },
        true
      )


      if (!fallbackResponse.shareUrl || !fallbackResponse.shareId) {
        throw new Error("Invalid response from share API")
      }

      return {
        shareUrl: fallbackResponse.shareUrl,
        shareId: fallbackResponse.shareId
      }
    } catch (error) {
      throw error
    }
  }

  /**
   * Get shared conversation
   */
  async getSharedConversation(shareId: string): Promise<ConversationWithMessages | null> {
    try {
      // First try the new MongoDB-backed endpoint
      const response = await fetch(`/api/conversations/share?shareId=${shareId}`)

      if (response.ok) {
        const data = await response.json()
        if (data.success && data.conversation) {
          return data.conversation as ConversationWithMessages
        }
      }

      // Fallback to the original endpoint if the new one fails
      const fallbackResponse = await secureApi.get(
        `/api/rohith/share?shareId=${shareId}`,
        false // No auth required for public shares
      )

      if (fallbackResponse.success && fallbackResponse.conversation) {
        return fallbackResponse.conversation
      }
      return null
    } catch (error) {
      return null
    }
  }

  /**
   * Get system status and capabilities
   */
  async getSystemStatus(): Promise<SystemStatus> {
    try {
      const response = await secureApi.get(
        "/sota-graph/status",
        false, // No auth required for status
        { enableCache: true, cacheDuration: 30000 } // 30 seconds cache
      ) as SystemStatus

      return response
    } catch (error) {
      // Return default status on error
      return {
        status: "offline",
        authenticity_guarantee: false,
        unified_graph: {
          total_nodes: 0,
          last_updated: new Date()
        },
        capabilities: [],
        response_time_avg: 0
      }
    }
  }

  /**
   * Clear user context cache (useful after profile updates)
   */
  clearUserContextCache(userId?: string): void {
    const targetUserId = userId || getCurrentUserId()
    if (targetUserId) {
      this.userContextCache.delete(targetUserId)
    }
  }

  /**
   * Clear conversation cache for a specific conversation
   */
  private clearConversationCache(conversationId: string): void {
    // Clear from secure API cache
    const cacheKeys = [
      `/api/rohith/history/${conversationId}`,
      `/api/rohith/conversations` // Will clear user's conversation list cache
    ]

    // Access the cache control from secure-api
    import("@/lib/secure-api").then(({ CacheControl }) => {
      cacheKeys.forEach(key => CacheControl.delete(key))
    })
  }

  /**
   * Format conversation title from first message (truncate if needed)
   */
  static formatConversationTitle(firstMessage: string): string {
    const maxLength = 60
    if (firstMessage.length <= maxLength) {
      return firstMessage
    }

    return firstMessage.substring(0, maxLength - 3) + "..."
  }

  /**
   * Create a new message object
   */
  static createMessage(
    role: "user" | "assistant",
    content: string,
    context?: any
  ): Message {
    return {
      id: crypto.randomUUID(),
      role,
      content,
      timestamp: new Date(),
      context
    }
  }
}

// Export singleton instance
export const rohithAPI = RohithAPI.getInstance()

// Export convenience functions
export const loadUserContext = (userId?: string) => rohithAPI.loadUserContext(userId)
export const getConversations = (userId?: string) => rohithAPI.getConversations(userId)
export const getConversationHistory = (conversationId: string) => rohithAPI.getConversationHistory(conversationId)
export const createConversation = (firstMessage: string, userId?: string) => rohithAPI.createConversation(firstMessage, userId)
export const sendMessage = (message: string, conversationId: string, userId?: string) => rohithAPI.sendMessage(message, conversationId, userId)
export const deleteConversation = (conversationId: string) => rohithAPI.deleteConversation(conversationId)
export const updateConversationTitle = (conversationId: string, newTitle: string) => rohithAPI.updateConversationTitle(conversationId, newTitle)
export const getSystemStatus = () => rohithAPI.getSystemStatus()
export const clearUserContextCache = (userId?: string) => rohithAPI.clearUserContextCache(userId)
export const formatConversationTitle = RohithAPI.formatConversationTitle
export const createMessage = RohithAPI.createMessage
export const shareConversation = (conversationId: string) => rohithAPI.shareConversation.bind(rohithAPI)(conversationId)
export const getSharedConversation = (shareId: string) => rohithAPI.getSharedConversation(shareId)
export const submitFeedback = (conversationId: string, messageId: string, isPositive: boolean, userId?: string) => rohithAPI.submitFeedback(conversationId, messageId, isPositive, userId)